-> JavaScript is a popular programming language that has a wide range of applications.
-> JavaScript was previously used mainly for making webpages interactive such as form validation, animation, etc. 

-> Nowadays, JavaScript is also used in many other areas such as server-side development, mobile app development and so on.



-> Because of its wide range of applications, you can run JavaScript in several ways:
• Using console tab of web browsers
• Using Node.js
• By creating web pages



1. Using Console Tab of Web Browsers
-> All the popular web browsers have built-in JavaScript engines. 

-> Hence, you can run JavaScript on a browser. 

To run JavaScript on a browser,
1. Open your favorite browser (here we will use Google Chrome).
2. Open the developer tools by right clicking on an empty area and select Inspect. Shortcut: F12.
3. On the developer tools, go to the console tab. Then, write JavaScript code and press enter to run the code.




2. Using Node.js
-> Node is a back-end run-time environment for executing JavaScript code. 

-> To run JS using Node.js, follow these steps:
1. Install the latest version of Node.js.
2. Install an IDE/Text Editor like Visual Studio Code. In VS code, create a file > write JS code > save it with .js extension.
3. Open up the terminal/command prompt > navigate to the file location > type node hello.js > hit enter.
4. You will get output on the terminal.



Note: It is also possible to run JavaScript on the terminal/command prompt directly. 
For that, simply type node and press enter. Then you can start writing JS code




3. By Creating Web Pages

-> JavaScript was initially created to make web pages interactive, that's why JavaScript and HTML go hand in hand. 

To run JS from a webpage, follow these steps:

1. Open VS Code > Go to File > New File > Save it with .html extension. 
For example, main.html.

2. Copy this doctype (minimum valid HTML code) and save it in the file.
<!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8">
<title>Programiz</title>
</head>
<body>
 <script src=""></script>
</body>
</html>

3. Similarly create a JS file, write the following JS code and save it with .js
extension like main.js.
console.log('hello world');

4. From inside the HTML file, we need to link the main.js file to use it. You 
can achieve that by adding the following code in main.html.
<script scr="main.js"></script>

5. Open the main.html file using a browser.

6. To check if our JS code ran or not, Right click on the web page > Inspect > Choose console tab




JavaScript Variables and Constants:

JavaScript Variables:

-> In programming, a variable is a container (storage area) to hold data. 

For example,
let num = 5;
Here, num is a variable. It's storing 5.




JavaScript Declare Variables:

-> In JavaScript, we use either var or let keyword to declare variables. 

For example,
var x;
let y;
Here, x and y are variables.




JavaScript var Vs let:

-> Both var and let are used to declare variables. 
-> However, there are some differences between them.


-> var is used in the older versions of JavaScript
    let is the new way of declaring variables starting ES6 (ES2015).

-> var is function scoped
    let is block scoped. 

-> For example, var x; 
    For example, let y;



Notes: 
-> It is recommended we use let instead of var. 
-> However, there are a few browsers that do not support let.




JavaScript Initialize Variables:

-> We use the assignment operator = to assign a value to a variable.
let x;
x = 5;
Here, 5 is assigned to variable x.


-> You can also initialize variables during its declaration.
let x = 5;
let y = 6;


-> In JavaScript, it's possible to declare variables in a single statement.
let x = 5, y = 6, z = 7;


-> If you use a variable without initializing it, it will have an undefined value.
let x; // x is the name of the variable
console.log(x); // undefined
Here x is the variable name and since it does not contain any value, it will be undefined.




Change the Value of Variables:

-> It's possible to change the value stored in the variable. 

For example,
// 5 is assigned to variable x
let x = 5; 
console.log(x); // 5

// vaue of variable x is changed
x = 3; 
console.log(x); // 3



Notes:
-> The value of a variable may vary. 
-> Hence, the name variable.




Rules for Naming JavaScript Variables:

The rules for naming variables are:

1. Variable names must start with either a letter, an underscore _, or the dollar sign $. 

For example, 
//valid
let a = 'hello';
let _a = 'hello';
let $a = 'hello';



2. Variable names cannot start with numbers.

For example, 
//invalid
Let 1a = 'hello'; // this gives an error



3. JavaScript is case-sensitive. So y and Y are different variables. 

For example, 
let y = "hi";
let Y = 5;
console.log(y); // hi
console.log(Y); // 5



4. Keywords cannot be used as variable names. 

For example, 
//invalid
let new = 5; // Error! new is a keyword.



Notes:
• Though you can name variables in any way you want, it's a good practice to give a descriptive variable name. 
        If you are using a variable to store the number of apples, it better to use apples or numberOfApples rather than x or n.
• In JavaScript, the variable names are generally written in camelCase if it has multiple words. 
        For example, firstName, annualSalary, etc.




JavaScript Constants:

-> The const keyword was also introduced in the ES6(ES2015) version to create constants. 

For example,
const x = 5;

-> Once a constant is initialized, we cannot change its value.
const x = 5;
x = 10; // Error! constant cannot be changed.
console.log(x)

-> Simply, a constant is a type of variable whose value cannot be changed.
-> Also, you cannot declare a constant without initializing it. 

For example,
const x; // Error! Missing initializer in const declaration.
x = 5;
console.log(x)


Notes: 
-> If you are sure that the value of a variable won't change throughout the program, it's recommended to use const. 
-> However, there are a few browsers that do not support const.




JavaScript console.log():

-> All modern browsers have a web console for debugging. 

-> The console.log() method is used to write messages to these consoles. 

For example,
let sum = 44;
console.log(sum); // 44

-> When you run the above code, 44 is printed on the console.


-> console.log() Syntax:

Its syntax is:
console.log(message);
Here, the message refers to either a variable or a value.


Notes: 
-> We will be using the console.log() method to display the output in our upcoming lessons.


Example 1: Print a Sentence
// program to print a sentence
// passing string
console.log("I love JS");

Output:
I love JS



Example 2: Print Values Stored in Variables
// program to print variables values
// storing values
const greet = 'Hello';
const name = 'Jack';
console.log(greet + ' ' + name);

Output:
Hello Jack




-> As you can see from these examples, console.log() makes it easier to see the value inside a variable. 

-> That's why it's commonly used for testing/debugging code.
-> The console object also has various methods other than console.log().




JavaScript Data Types:

There are different types of data that we can use in a JavaScript program. 

For example,
const x = 5;
const y = "Hello";
Here,
• 5 is an integer data.
• "Hello" is a string data.




JavaScript Data Types:

-> There are eight basic data types in JavaScript. 

They are:
Data Types            Description                                           Example
String                represents textual data                              'hello', "hello world!" etc
Number                an integer or a floating-point number                 3, 3.234, 3e-2 etc.
BigInt                an integer with arbitrary precision                   900719925124740999n , 1n etc.
Boolean               Any of two values: true or false                      true and false
undefined             a data type whose variable is not initialized         let a;
null                  denotes a null value                                  let a = null;
Symbol                data type whose instances are unique and immutable    let value = Symbol('hello');
Object                key-value pairs of collection of data                 let student = { };


-> Here, all data types except Object are primitive data types, whereas Object is non-primitive.


Notea: 
-> The Object data type (non-primitive type) can store collections of data, whereas primitive data type can only store a single data.




JavaScript String:

-> String is used to store text. 

-> In JavaScript, strings are surrounded by quotes:
• Single quotes: 'Hello'
• Double quotes: "Hello"
• Backticks: `Hello`

For example,
//strings example
const name = 'ram';
const name1 = "hari";
const result = `The names are ${name} and ${name1}`;



-> Single quotes and double quotes are practically the same and you can use either of them.


-> Backticks are generally used when you need to include variables or expressions into a string. 
-> This is done by wrapping variables or expressions with ${variable or expression} as shown above.




JavaScript Number:

-> Number represents integer and floating numbers (decimals and exponentials). 

For example,
const number1 = 3;
const number2 = 3.433;
const number3 = 3e5 // 3 * 10^5

-> A number type can also be +Infinity, -Infinity, and NaN (not a number). 

For example,
const number1 = 3/0;
console.log(number1); // Infinity
const number2 = -3/0;
console.log(number2); // -Infinity


// strings can't be divided by numbers
const number3 = "abc"/3; 
console.log(number3); // NaN



JavaScript BigInt:

-> In JavaScript, Number type can only represent numbers less than (2^53 - 1) and more than -(2^53 - 1). 
-> However, if you need to use a larger number than that, you can use the BigInt data type.


-> A BigInt number is created by appending n to the end of an integer. 

For example,
// BigInt value
const value1 = 900719925124740998n;

// Adding two big integers
const result1 = value1 + 1n;
console.log(result1); // "900719925124740999n"
const value2 = 900719925124740998n;

// Error! BitInt and number cannot be added
const result2 = value2 + 1; 
console.log(result2); 
Output:
900719925124740999n

Uncaught TypeError: Cannot mix BigInt and other types


Note: 
-> BigInt was introduced in the newer version of JavaScript and is not supported by many browsers including Safari. 




JavaScript Boolean:

-> This data type represents logical entities.

Boolean represents one of two values: true or false. 

It is easier to think of it as a yes/no switch. 
For example,
const dataChecked = true;
const valueCounted = false;




JavaScript undefined:

-> The undefined data type represents value that is not assigned. 
-> If a variable is declared but the value is not assigned, then the value of that variable will be undefined. 

For example,
let name;
console.log(name); // undefined

-> It is also possible to explicitly assign a variable value undefined. 

For example,
let name = undefined;
console.log(name); // undefined

Notes: 
-> It is recommended not to explicitly assign undefined to a variable. 
-> Usually, null is used to assign 'unknown' or 'empty' value to a variable.




JavaScript null:

-> In JavaScript, null is a special value that represents empty or unknown value. 

For example,
const number = null;

-> The code above suggests that the number variable is empty.

Notes: null is not the same as NULL or Null.




JavaScript Symbol:

-> This data type was introduced in a newer version of JavaScript (from ES2015).
-> A value having the data type Symbol can be referred to as a symbol value. 

-> Symbol is an immutable primitive value that is unique. 

For example,
// two symbols with the same description
const value1 = Symbol('hello');
const value2 = Symbol('hello');

-> Though value1 and value2 both contain 'hello', they are different as they are of the Symbol type.




JavaScript Object:

-> An object is a complex data type that allows us to store collections of data. 

For example,
const student = {
 firstName: 'ram',
 lastName: null,
 class: 10
}




JavaScript Type:

-> JavaScript is a dynamically typed (loosely typed) language. 
-> JavaScript automatically determines the variables' data type for you.

-> It also means that a variable can be of one data type and later it can be changed to another data type. 

For example,
// data is of undefined type
let data;

// data is of integer type
data = 5;

// data is of string type
data = "JavaScript Programming";




JavaScript typeof:

-> To find the type of a variable, you can use the typeof operator. 


For example,

const name = 'ram';
typeof(name); // returns "string"

const number = 4;
typeof(number); //returns "number"

const valueChecked = true;
typeof(valueChecked); //returns "boolean"

const a = null;
typeof(a); // returns "object"


-> Notice that typeof returned "object" for the null type. 
-> This is a known issue in JavaScript since its first release.




JavaScript Operators:

What is an Operator?
-> In JavaScript, an operator is a special symbol used to perform operations on operands (values and variables). 

For example,
2 + 3; // 5

Here + is an operator that performs addition, and 2 and 3 are operands.



JavaScript Operator Types:
-> There are many operator perform in JavaScipt:
• Assignment Operators
• Arithmetic Operators
• Comparison Operators
• Logical Operators
• Bitwise Operators
• String Operators
• Other Operators





JavaScript Assignment Operators:


Assignment operators are used to assign values to variables. 

For example,
const x = 5;

Here, the = operator is used to assign value 5 to variable x.

Here's a list of commonly used assignment operators:
Operator        Name                        Example
=               Assignment operator         a = 7; // 7
+=              Addition assignment         a += 5; // a = a + 5
-=              Subtraction Assignment      a -= 2; // a = a - 2
*=              Multiplication Assignment   a *= 3; // a = a * 3
/=              Division Assignment         a /= 2; // a = a / 2
%=              Remainder Assignment        a %= 2; // a = a % 2
**=             Exponentiation Assignment   a **= 2; // a = a**2




JavaScript Arithmetic Operators:

-> Arithmetic operators are used to perform arithmetic calculations. 

For example,
const number = 3 + 5; // 8
Here, the + operator is used to add two operands.


Operator      Name                            Example
+             Addition                        x + y
-             Subtraction                     x - y
*             Multiplication                  x * y
/             Division                        x / y
%             Remainder                       x % y
++            Increment (increments by 1)     ++x or x++
--            Decrement (decrements by 1)     --x or x--
**            Exponentiation (Power)          x ** y




Example 1: Arithmetic operators in JavaScript
let x = 5;
let y = 3;

// addition
console.log('x + y = ', x + y); // 8

// subtraction
console.log('x - y = ', x - y); // 2

// multiplication
console.log('x * y = ', x * y); // 15

// division
console.log('x / y = ', x / y); // 1.6666666666666667

// remainder
console.log('x % y = ', x % y); // 2

// increment
console.log('++x = ', ++x); // x is now 6
console.log('x++ = ', x++); // prints 6 and then increased to 7
console.log('x = ', x); // 7

// decrement
console.log('--x = ', --x); // x is now 6
console.log('x-- = ', x--); // prints 6 and then decreased to 5
console.log('x = ', x); // 5

//exponentiation
console.log('x ** y =', x ** y);


Notes: 
-> The ** operator was introduced in ECMAScript 2016 and some browsers may not support them. 

-> JavaScript Comparison OperatorsComparison operators compare two values and return a boolean value, either true or false. 

For example,
const a = 3, b = 2;
console.log(a > b); // true 


-> Here, the comparison operator > is used to compare whether a is greater than b.


Operator          Description                                                                                         Example
==                Equal to: returns true if the operands are equal                                                    x == y 
!=                Not equal to: returns true if the operands are not equal                                            x != y
===               Strict equal to: true if the operands are equal and of the same type                                x === y
!==               Strict not equal to: true if the operands are equal but of different type or not equal at all       x !== y
>                 Greater than: true if left operand is greater than the right operand                                x > y
>=                Greater than or equal to: true if left operand is greater than or equal to the right operand        x >= y
<                 Less than: true if the left operand is less than the right operand                                  x < y
<=                Less than or equal to: true if the left operand is less than or equal to the right operand          x <= y




Example 2: Comparison operators in JavaScript:

// equal operator
console.log(2 == 2); // true
console.log(2 == '2'); // true

// not equal operator
console.log(3 != 2); // true
console.log('hello' != 'Hello'); // true

// strict equal operator
console.log(2 === 2); // true
console.log(2 === '2'); // false

// strict not equal operator
console.log(2 !== '2'); // true
console.log(2 !== 2); // false


-> Comparison operators are used in decision-making and loops



Example: Equal to Operator

const a = 5, b = 2, c = 'hello';
// equal to operator
console.log(a == 5); // true
console.log(b == '2'); // true
console.log(c == 'Hello'); // false
== evaluates to true if the operands are equal.



Notes: 
-> In JavaScript, == is a comparison operator, whereas = is an assignment operator. 
-> If you mistakenly use = instead of ==, you might get unwanted result.




Example : Not Equal to Operator

const a = 3, b = 'hello';
// not equal operator
console.log(a != 2); // true
console.log(b != 'Hello'); // true


Notes:
!= evaluates to true if the operands are not equal.





Example : Strict Equal to Operator

const a = 2;
// strict equal operator
console.log(a === 2); // true
console.log(a === '2'); // false



Notes:
-> === evaluates to true if the operands are equal and of the same type. 
-> Here 2 and '2'are the same numbers but the data type is different. 
-> And === also checks for the data type while comparing.


Notes: 
-> The difference between == and === is that: == evaluates to true if the operands are equal, 
      however, === evaluates to true only if the operands are equal and of the same type



Example : Strict Not Equal to Operator

const a = 2, b = 'hello';
// strict not equal operator
console.log(a !== 2); // false
console.log(a !== '2'); // true
console.log(b !== 'Hello'); // true


Notes:
-> !== evaluates to true if the operands are strictly not equal. 
-> It's the complete opposite of strictly equal ===.
-> In the above example, 2 != '2' gives true. 
-> It's because their types are different even though they have the same value.


Example : Greater than Operator
const a = 3;

// greater than operator
console.log(a > 2); // true

Notes:
> evaluates to true if the left operand is greater than the right operand.



Example : Greater than or Equal to Operator

const a = 3;
// greater than or equal operator
console.log(a >= 3); //true

Notes:
-> >= evaluates to true if the left operand is greater than or equal to the right operand.




Example : Less than Operator

const a = 3, b = 2;
// less than operator
console.log(a < 2); // false
console.log(b < 3); // true

Notes:
-> < evaluates to true if the left operand is less than the right operand.




Example : Less than or Equal to Operator

const a = 2;
// less than or equal operator
console.log(a <= 3) // true
console.log(a <= 2); // true

Notes:
-> <= evaluates to true if the left operand is less than or equal to the right operand.




JavaScript Logical Operators:

-> Logical operators perform logical operations and return a boolean value, either true or false. 

For example,
const x = 5, y = 3;
(x < 6) && (y < 5); // true

-> Here, && is the logical operator AND. 

Since both x < 6 and y < 5 are true, the result is true.




Operator        Description                                                                             Example
&&              Logical AND: true if both the operands are true, else returns false                     x && y
||              Logical OR: true if either of the operands is true; returns false if both are false     x || y
!               Logical NOT: true if the operand is false and vice-versa.                               !x




Example 3: Logical Operators in JavaScript

// logical AND
console.log(true && true); // true
console.log(true && false); // false

// logical OR
console.log(true || false); // true

// logical NOT
console.log(!true); // false

Output:
true
false
true
false



-> Logical operators are used in decision making and loops.




Example : Logical AND Operator

const a = true, b = false;
const c = 4;

// logical AND
console.log(a && a); // true
console.log(a && b); // false
console.log((c > 2) && (c < 2)); // false


Notes:
-> && evaluates to true if both the operands are true, else evaluates to false.
-> You can also use logical operators with numbers. 

-> In JavaScript, 0 is false and all non-zero values are true.



Example : Logical OR Operator

const a = true, b = false, c = 4;

// logical OR
console.log(a || b); // true
console.log(b || b); // false
console.log((c>2) || (c<2)); // true


-> || evaluates to true if either of the operands is true. 
-> If both operands are false, the result is false.


Example : Logical NOT Operator

const a = true, b = false;

// logical NOT
console.log(!a); // false
console.log(!b); // true


Notes:
-> ! evaluates to true if the operand is false and vice-versa.




JavaScript Bitwise Operators:
-> Bitwise operators perform operations on binary representations of numbers.


Operator       Description
&              Bitwise AND
|              Bitwise OR
^              Bitwise XOR
~              Bitwise NOT
<<             Left shift
>>             Sign-propagating right shift
>>>            Zero-fill right shift





JavaScript String Operators:

-> In JavaScript, you can also use the + operator to concatenate (join) two or more strings.



Example 4: String operators in JavaScript
// concatenation operator
console.log('hello' + 'world');
let a = 'JavaScript';
a += ' tutorial'; // a = a + ' tutorial';
console.log(a);

Output:
helloworld
JavaScript tutorial



Note: When + is used with strings, it performs concatenation. 
-> However, when + is used with numbers, it performs addition.



Other JavaScript Operators:

-> Here's a list of other operators available in JavaScript.



Operator           Description                                                                Example
,                  evaluates multiple operands and returns the value of the last operand.     let a = (1, 3 , 4); // 4
?:                 returns value based on the condition                                       x(5 > 3) ? 'success' : 'error'; // "success"
delete             deletes an object's property, or an element of an array                    delete x
typeof             returns a string indicating the data type typeof 3;                        // "number"
void               discards the expression's return value                                     void(x)
in                 returns true if the specified property is in the object                    prop in object
instanceof         returns true if the specified object is of of the specified object type    object instanceof object_type




JavaScript Comments:

-> JavaScript comments are hints that a programmer can add to make their code easier to read and understand. 
-> They are completely ignored by JavaScript engines.


There are two ways to add comments to code:
• // - Single Line Comments
• /* */ -Multi-line Comments




Single Line Comments:

-> In JavaScript, any line that starts with // is a single line comment. 

For example,
name = "Jack";

// printing name on the console
console.log("Hello " + name);

-> Here, // printing name on the console is a comment.

You can also use single line comment like this:

name = "Jack";
console.log("Hello " + name); // printing name on the console




Multi-line Comments:

-> In Javascript, any text between /* and */ is a multi-line comment. 

For example,
/* The following program contains the source code for a game 
called Baghchal. 

Baghchal is a popular board game in Nepal where two players 
choose either sheep or tiger. It is played on a 5x5 grid.

For the player controlling the tiger to win, they must capture 
all the sheep. There are altogether 4 tigers on the board.

For the sheep to win, all tigers must be surrounded and cornered 
so that they cannot move. The player controlling the sheep has 
20 sheep at his disposal.*/


-> Since the rest of the source code will be used to implement the rules of the game, 
          the comment above is a good example where you might use a multi-line comment.




Using Comments for Debugging:

-> Comments can also be used to disable code to prevent it from being executed. 

For example,
console.log("some code");
console.log("Error code);
console.log("other code");

-> If you get an error while running the program, instead of removing the error-prone code, you can use comments to disable it from being executed; 

this can be a valuable debugging tool.
console.log("some code");
// console.log("Error code);
console.log("other code");


Pro Tip: 
-> Remember the shortcut for using comments; it can be really helpful. 
-> For most code editors, it's Ctrl + / for Windows and Cmd + / for Mac.





Make Code Easier to Understand:

-> As a JavaScript developer, you will not only write code but may also have to modify code written by other developers.

-> If you write comments on your code, it will be easier for you to understand the code in the future. 
-> Also, it will be easier for your fellow developers to understand the code.

-> As a general rule of thumb, use comments to explain why you did something rather than how you did something, and you are good.


Notes: 
-> Comments shouldn't be the substitute for a way to explain poorly written code in English. 
-> You should always write well-structured and self-explanatory code. And, then use comments.




JavaScript Type Conversions:

-> The process of converting one data type to another data type is called type conversion. 

There are two types of type conversion in JavaScript.
• Implicit Conversion
• Explicit Conversion




JavaScript Implicit Conversion:

-> In certain situations, JavaScript automatically converts one data type to another (to the right type). 
-> This is known as implicit conversion.


Example 1: Implicit Conversion to String
// numeric string used with + gives string type

let result;
result = '3' + 2; 
console.log(result) // "32"

result = '3' + true; 
console.log(result); // "3true"

result = '3' + undefined; 
console.log(result); // "3undefined"

result = '3' + null; 
console.log(result); // "3null"


Notes: 
-> When a number is added to a string, JavaScript converts the number to a string before concatenation.




Example 2: Implicit Conversion to Number
// numeric string used with - , / , * results number type

let result;
result = '4' - '2'; 
console.log(result); // 2

result = '4' - 2;
console.log(result); // 2

result = '4' * 2;
console.log(result); // 8

result = '4' / 2;
console.log(result); // 2




Example 3: Non-numeric String Results to NaN
// non-numeric string used with +, - , / , * results to NaN

let result;
result = 'hello' - 'world';
console.log(result); // NaN

result = '4' - 'hello';
console.log(result); // NaN




Example 4: Implicit Boolean Conversion to Number
// if boolean is used, true is 1, false is 0

let result;
result = '4' - true;
console.log(result); // 3

result = 4 + true;
console.log(result); // 5

result = 4 + false;
console.log(result); // 4


Notes: 
-> JavaScript considers 0 as false and all non-zero number as true. 
-> And, if true is converted to a number, the result is always 1.





Example 5: null Conversion to Number

// null is 0 when used with number

let result;
result = 4 + null;
console.log(result); // 4

result = 4 - null;
console.log(result); // 4




Example 6: undefined used with number, boolean or null
// Arithmetic operation of undefined with number, boolean or null gives NaN

let result;
result = 4 + undefined;
console.log(result); // NaN

result = 4 - undefined;
console.log(result); // NaN

result = true + undefined;
console.log(result); // NaN

result = null + undefined;
console.log(result); // NaN




JavaScript Explicit Conversion:

-> You can also convert one data type to another as per your needs. 
-> The type conversion that you do manually is known as explicit type conversion.

-> In JavaScript, explicit type conversions are done using built-in methods.


Here are some common methods of explicit conversions.



1. Convert to Number Explicitly
To convert numeric strings and boolean values to numbers, you can use Number(). 

For example,
let result;
// string to number
result = Number('324');
console.log(result); // 324

result = Number('324e-1') 
console.log(result); // 32.4


// boolean to number
result = Number(true);
console.log(result); // 1

result = Number(false);
console.log(result); // 0

-> In JavaScript, empty strings and null values return 0. 

For example,
let result;
result = Number(null);
console.log(result); // 0

let result = Number(' ')
console.log(result); // 0

-> If a string is an invalid number, the result will be NaN. For example,

let result;
result = Number('hello');
console.log(result); // NaN

result = Number(undefined);
console.log(result); // NaN

result = Number(NaN);
console.log(result); // NaN

Notes: 
-> You can also generate numbers from strings using parseInt(), parseFloat(), unary operator + and Math.floor(). 


For example,

let result;
result = parseInt('20.01');
console.log(result); // 20

result = parseFloat('20.01');
console.log(result); // 20.01

result = +'20.01';
console.log(result); // 20.01

result = Math.floor('20.01');
console.log(result); // 20





2. Convert to String Explicitly
To convert other data types to strings, you can use either String() or toString(). 

For example,

//number to string
let result;
result = String(324);
console.log(result); // "324"

result = String(2 + 4);
console.log(result); // "6"

//other data types to string
result = String(null);
console.log(result); // "null"

result = String(undefined);
console.log(result); // "undefined"

result = String(NaN);
console.log(result); // "NaN"

result = String(true);
console.log(result); // "true"

result = String(false);
console.log(result); // "false"


// using toString()
result = (324).toString();
console.log(result); // "324"

result = true.toString();
console.log(result); // "true"


Notes: 
-> String() takes null and undefined and converts them to string. 
-> However, toString() gives error when null are passed.




3. Convert to Boolean Explicitly
-> To convert other data types to a boolean, you can use Boolean().
-> In JavaScript, undefined, null, 0, NaN, '' converts to false. 


For example,
let result;
result = Boolean('');
console.log(result); // false

result = Boolean(0);
console.log(result); // false

result = Boolean(undefined);
console.log(result); // false

result = Boolean(null);
console.log(result); // false

result = Boolean(NaN);
console.log(result); // false


-> All other values give true. 

For example,
result = Boolean(324);
console.log(result); // true

result = Boolean('hello');
console.log(result); // true

result = Boolean(' ');
console.log(result); // true




JavaScript Type Conversion Table:

-> The table shows the conversion of different values to String, Number, and Boolean in JavaScript.


Value       String Conversion       Number Conversion        Boolean Conversion
1           "1"                     1                        true
0           "0"                     0                        false
"1"         "1"                     1                        true
"0"         "0"                     0                        true
"ten"       "ten"                   NaN                      true
true        "true"                  1                        true
false       "false"                 0                        false
null        "null"                  0                        false
undefined   "undefined"             NaN                      false
''          ""                      0                        false
' '         " "                     0                        true




JavaScript if...else Statement:

-> In computer programming, there may arise situations where you have to run a block of code among more than one alternatives. 


For example, assigning grades A, B or C based on marks obtained by a student.
-> In such situations, you can use the JavaScript if...else statement to create a program that can make decisions.


In JavaScript, there are three forms of the if...else statement.
1. if statement
2. if...else statement
3. if...else if...else statement




JavaScript if Statement:

The syntax of the if statement is:
if (condition) {
 // the body of if
}


-> The if statement evaluates the condition inside the parenthesis ().
1. If the condition is evaluated to true, the code inside the body of if is executed.
2. If the condition is evaluated to false, the code inside the body of if is skipped.

Notes:
-> The code inside { } is the body of the if statement.




Example : if Statement

// check if the number is positive
const number = prompt("Enter a number: ");

// check if number is greater than 0
if (number > 0) {
// the body of the if statement
 console.log("The number is positive");
}
console.log("The if statement is easy");

Output 1:
Enter a number: 2
The number is positive
The if statement is easy

-> Suppose the user entered 2. 
-> In this case, the condition number > 0 evaluates to true. And, the body of the if statement is executed.



Output 2:
Enter a number: -1
The if statement is easy

-> Suppose the user entered -1. 
-> In this case, the condition number > 0 evaluates to false. 

-> Hence, the body of the if statement is skipped.
-> Since console.log("The if statement is easy"); is outside the body of the ifstatement, it is always executed.
-> Comparison and logical operators are used in conditions.




JavaScript if...else statement:

-> An if statement can have an optional else clause. 


The syntax of the if...else statement is:
if (condition) {
 // block of code if condition is true
} else {
 // block of code if condition is false
}

-> The if..else statement evaluates the condition inside the parenthesis.


-> If the condition is evaluated to true,
1. the code inside the body of if is executed
2. the code inside the body of else is skipped from execution

-> If the condition is evaluated to false,
1. the code inside the body of else is executed
2. the code inside the body of if is skipped from execution




Example : if…else Statement

// check is the number is positive or negative/zero
const number = prompt("Enter a number: ");

// check if number is greater than 0
if (number > 0) {
 console.log("The number is positive");
}

// if number is not greater than 0
else {
 console.log("The number is either a negative number or 0");
}
console.log("The if...else statement is easy");

Output 1:
Enter a number: 2
The number is positive
The if...else statement is easy


-> Suppose the user entered 2. 
-> In this case, the condition number > 0 evaluates to true. 
-> Hence, the body of the if statement is executed and the body of the else statement is skipped.



Output 2:
Enter a number: -1
The number is either a negative number or 0
The if...else statement is easy

-> Suppose the user entered -1. In this case, the condition number > 0 evaluates to false. 
-> Hence, the body of the else statement is executed and the body of the if statement is skipped.




JavaScript if...else if statement:

-> The if...else statement is used to execute a block of code among two alternatives. 
-> However, if you need to make a choice between more than two alternatives, if...else if...else can be used.

The syntax of the if...else if...else statement is:
if (condition1) {
 // code block 1
} else if (condition2){
 // code block 2
} else {
 // code block 3
}


• If condition1 evaluates to true, the code block 1 is executed.
• If condition1 evaluates to false, then condition2 is evaluated. 
o If the condition2 is true, the code block 2 is executed.
o If the condition2 is false, the code block 3 is executed.




Example : if...else if Statement

// check if the number if positive, negative or zero
const number = prompt("Enter a number: ");

// check if number is greater than 0
if (number > 0) {
 console.log("The number is positive");
}

// check if number is 0
else if (number == 0) {
console.log("The number is 0");
}

// if number is neither greater than 0, nor zero
else {
 console.log("The number is negative");
}
console.log("The if...else if...else statement is easy");

Output:
Enter a number: 0
The number is 0
The if...else if...else statement is easy



-> Suppose the user entered 0, then the first test condition number > 0 evaluates to false. 
-> Then, the second test condition number == 0 evaluates to true and its corresponding block is executed.




Nested if...else Statement:

-> You can also use an if...else statement inside of an if...else statement. 
-> This is known as nested if...else statement.



Example : Nested if...else Statement
// check if the number is positive, negative or zero
const number = prompt("Enter a number: ");
if (number >= 0) {
 if (number == 0) {
 console.log("You entered number 0");
 } else {
 console.log("You entered a positive number");
 }
} else {
 console.log("You entered a negative number");
}

Output:
Enter a number: 5
You entered a positive number


-> Suppose the user entered 5. 
-> In this case, the condition number >= 0 evaluates to true, and the control of the program goes inside the outer if statement.

-> Then, the test condition, number == 0, of the inner if statement is evaluated. 
-> Since it's false, the else clause of the inner if statement is executed.


Notea: 
-> As you can see, nested if...else makes our logic complicated and we should try to avoid using nested if...else whenever possible.




Body of if...else With Only One Statement:

-> If the body of if...else has only one statement, we can omit { } in our programs. 

For example, 

you can replace

const number = 2;
if (number > 0) {
 console.log("The number is positive.");
} else {
 console.log("The number is negative or zero.");
}


with

const number = 2;
if (number > 0)
 console.log("The number is positive.");
else
 console.log("The number is negative or zero.");


Output:
The number is positive.




More on Decision Making:

-> In certain situations, a ternary operator can replace an if...else statement.
-> If you need to make a choice between more than one alternatives based on a given test condition, the switch statement can be used.




JavaScript for loop:

-> In programming, loops are used to repeat a block of code.
-> For example, if you want to show a message 100 times, then you can use a loop. 
-> It's just a simple example; you can achieve much more with loops.


The syntax of the for loop is:
for(initialExpression; condition; updateExpression) {
 // for loop body
}



Here,
1. The initialExpression initializes and/or declares variables and executes only once.
2. The condition is evaluated. 
   o If the condition is false, the for loop is terminated.
   o if the condition is true, the block of code inside of the for loop is executed.
3. The updateExpression updates the value of initialExpression when the condition is true.
4. The condition is evaluated again.This process continues until the condition is false.




Example : Display a Text Five Times

// program to display text 10 times
const n = 5;

// looping from i = 1 to 5
for (let i = 1; i <= n; i++) {
 console.log(`I love JavaScript.`);
}

Output:
I love JavaScript.
I love JavaScript.
I love JavaScript.
I love JavaScript.
I love JavaScript.




Example 2: Display Numbers from 1 to 5:

// program to display numbers from 1 to 5
const n = 5;

// looping from i = 1 to 5
// in each iteration, i is increased by 1
for (let i = 1; i <= n; i++) {
 console.log(i); // printing the value of i
}

Output:
1
2
3
4
5




Example 3: Display Sum of n Natural Numbers

// program to display the sum of natural numbers
let sum = 0;
const n = 100

// looping from i = 1 to n
// in each iteration, i is increased by 1
for (let i = 1; i <= n; i++) {
 sum += i; // sum = sum + i
}
console.log('sum:', sum);

Output:
sum: 5050

-> Here, the value of sum is 0 initially. 
-> Then, a for loop is iterated from i = 1 to 100. 
-> In each iteration, i is added to sum and its value is increased by 1.
-> When i becomes 101, the test condition is false and sum will be equal to 0 + 1 + 2 + ... + 100.




The above program to add sum of natural numbers can also be written as:

// program to display the sum of n natural numbers
let sum = 0;
const n = 100;

// looping from i = n to 1
// in each iteration, i is decreased by 1
for(let i = n; i >= 1; i-- ) {

// adding i to sum in each iteration
 sum += i; // sum = sum + i
}
console.log('sum:',sum);


-> This program also gives the same output as the above example. 
-> You can accomplish the same task in many different ways in programming; programming is all about logic.
-> Although both ways are correct, you should try to make your code more readable.




JavaScript Infinite for loop:

-> If the test condition in a for loop is always true, it runs forever (until memory is full). 

For example,
// infinite for loop
for(let i = 1; i > 0; i++) {
 // block of code
}

-> In the above program, the condition is always true which will then run the code for infinite times.




JavaScript while and do...while Loop:

-> In programming, loops are used to repeat a block of code. 
-> For example, if you want to show a message 100 times, then you can use a loop. 
-> It's just a simple example; you can achieve much more with loops.


JavaScript while Loop:

The syntax of the while loop is:
while (condition) {
 // body of loop
}



Here,
1. A while loop evaluates the condition inside the parenthesis ().
2. If the condition evaluates to true, the code inside the while loop is executed.
3. The condition is evaluated again.
4. This process continues until the condition is false.
5. When the condition evaluates to false, the loop stops.




Example : Display Numbers from 1 to 5
// program to display numbers from 1 to 5
// initialize the variable
let i = 1, n = 5;
// while loop from i = 1 to 5
while (i <= n) {
 console.log(i);
 i += 1;
}


Output:
1
2
3
4
5




Example : Sum of Positive Numbers Only

// program to find the sum of positive numbers
// if the user enters a negative numbers, the loop ends
// the negative number entered is not added to sum

let sum = 0;

// take input from the user
let number = parseInt(prompt('Enter a number: '));
    while(number >= 0) {
        // add all positive numbers
        sum += number;
        // take input again if the number is positive
        number = parseInt(prompt('Enter a number: '));
    }
    // display the sum
    console.log(`The sum is ${sum}.`);

Output:
Enter a number: 2
Enter a number: 5
Enter a number: 7
Enter a number: 0
Enter a number: -3
The sum is 14.



-> In the above program, the user is prompted to enter a number.

-> Here, parseInt() is used because prompt() takes input from the user as a string. 
-> And when numeric strings are added, it behaves as a string. 

-> For example, '2' + '3' = '23'. 
-> So parseInt() converts a numeric string to number.


-> The while loop continues until the user enters a negative number. 
-> During each iteration, the number entered by the user is added to the sum variable.

-> When the user enters a negative number, the loop terminates. 
-> Finally, the total sum is displayed.





JavaScript do...while Loop:

The syntax of do...while loop is:
do {
 // body of loop
} while(condition)


Here,
1. The body of the loop is executed at first. Then the condition is evaluated.
2. If the condition evaluates to true, the body of the loop inside the do statement is executed again.
3. The condition is evaluated once again.
4. If the condition evaluates to true, the body of the loop inside the dostatement is executed again.
5. This process continues until the condition evaluates to false. Then the loop stops.



Notes: 
-> do...while loop is similar to the while loop. 
-> The only difference is that in do…while loop, the body of loop is executed at least once.




Example : Display Numbers from 1 to 5

// program to display numbers
let i = 1;
const n = 5;

// do...while loop from 1 to 5
do {
 console.log(i);
 i++;
} while(i <= n);


Output:
1
2
3
4
5



Example : Sum of Positive Numbers
// to find the sum of positive numbers
// if the user enters negative number, the loop terminates
// negative number is not added to sum
let sum = 0;
let number = 0;

do {
 sum += number;
 number = parseInt(prompt('Enter a number: '));
} while(number >= 0)
console.log(`The sum is ${sum}.`);

Output 1:
Enter a number: 2
Enter a number: 4
Enter a number: -500
The sum is 6.


-> Here, the do...while loop continues until the user enters a negative number. 
-> When the number is negative, the loop terminates; the negative number is not added to the sum variable.


Output 2:
Enter a number: -80
The sum is 0.


-> The body of the do...while loop runs only once if the user enters a negative number.




Infinite while Loop:

-> If the condition of a loop is always true, the loop runs for infinite times (until the memory is full). 

For example,
// infinite while loop
while(true){
 // body of loop
}

Here is an example of an infinite do...while loop.
// infinite do...while loop
const count = 1;
do {
 // body of loop
} while(count == 1)

-> In the above programs, the condition is always true. 
-> Hence, the loop body will run for infinite times.




for Vs while Loop:

-> A for loop is usually used when the number of iterations is known. 


For example,
// this loop is iterated 5 times
for (let i = 1; i <=5; ++i) {
 // body of loop
}


-> And while and do...while loops are usually used when the number of iterations are unknown. 

For example,
while (condition) {
 // body of loop
}




JavaScript break Statement:

-> The break statement is used to terminate the loop immediately when it is encountered.


The syntax of the break statement is:
break [label];

Notes: 
-> label is optional and rarely used.




Example 1: break with for Loop

// program to print the value of i
for (let i = 1; i <= 5; i++) {

// break condition 
 if (i == 3) {
 break;
 }
 console.log(i);
}

Output:
1
2



-> In the above program, the for loop is used to print the value of i in each iteration. 

The break statement is used as:
if(i == 3) {
 break;
}

-> This means, when i is equal to 3, the break statement terminates the loop. 

-> Hence, the output doesn't include values greater than or equal to 3.

Notes: 
-> The break statement is almost always used with decision-making statements. 




Example 2: break with while Loop

// program to find the sum of positive numbers
// if the user enters a negative numbers, break ends the loop
// the negative number entered is not added to sum
let sum = 0, number;
while(true) {
 // take input again if the number is positive
 number = parseInt(prompt('Enter a number: '));
 // break condition
 if(number < 0) {
 break;
 }
 // add all positive numbers
 sum += number;
}
// display the sum
console.log(`The sum is ${sum}.`);



Output:
Enter a number: 1
Enter a number: 2
Enter a number: 3
Enter a number: -5
The sum is 6. 





-> In the above program, the user enters a number. 
-> The while loop is used to print the total sum of numbers entered by the user.


Here the break statement is used as:
if(number < 0) {
 break;
}

-> When the user enters a negative number, here -5, the break statement terminates the loop and the control flow of the program goes outside the loop.
-> Thus, the while loop continues until the user enters a negative number.




Break with Nested Loop:

-> When break is used inside of two nested loops, break terminates the inner loop. 

For example,
// nested for loops
// first loop
for (let i = 1; i <= 3; i++) {
 // second loop
 for (let j = 1; j <= 3; j++) {
 if (i == 2) {
 break;
 }
 console.log(`i = ${i}, j = ${j}`);
 }
}

Output:
i = 1, j = 1
i = 1, j = 2
i = 1, j = 3
i = 3, j = 1
i = 3, j = 2
i = 3, j = 3



-> In the above program, when i == 2, break statement executes. 
-> It terminates the inner loop and control flow of the program moves to the outer loop.
-> Hence, the value of i = 2 is never displayed in the output.



JavaScript Labeled break:

-> When using nested loops, you can also terminate the outer loop with a label statement.
-> However labeled break is rarely used in JavaScript because this makes the code harder to read and understand.
-> The break statement is also used with switch statements.




JavaScript continue Statement:

-> The continue statement is used to skip the current iteration of the loop and the control flow of the program goes to the next iteration.


The syntax of the continue statement is:
continue [label];

Notes: 
-> label is optional and rarely used.




Continue with for Loop:

-> In a for loop, continue skips the current iteration and control flow jumps to the updateExpression.


Example 1: Print the Value of i
// program to print the value of i
for (let i = 1; i <= 5; i++) {
 // condition to continue 
 if (i == 3) {
 continue;
 }
 console.log(i);
}


Output:
1
2
4
5




-> In the above program, for loop is used to print the value of i in each iteration.

Notice the continue statement inside the loop.
if(i == 3) {
 continue;
}


This means
• When i is equal to 3, the continue statement skips the third iteration.
• Then, i becomes 4 and the test condition and continue statement is evaluated again.
• Hence, 4 and 5 are printed in the next two iterations.



Notes: 
-> The continue statement is almost always used with decision making statements. 
-> The break statement terminates the loop entirely. 
-> However, the continue statement only skips the current iteration.




Example 2: Calculate Positive Number

// program to calculate positive numbers only
// if the user enters a negative number, that number is skipped from calculation
// negative number -> loop terminate
// non-numeric character -> skip iteration

let sum = 0;
let number = 0;

while (number >= 0) {
 
 // add all positive numbers
 sum += number;
 
 // take input from the user
 number = parseInt(prompt('Enter a number: '));
 
 // continue condition
 if (isNaN(number)) {
 console.log('You entered a string.');
 number = 0; // the value of number is made 0 again
 continue;
 }
}

// display the sum
console.log(`The sum is ${sum}.`);


Output:
Enter a number: 1
Enter a number: 2
Enter a number: hello
You entered a string.
Enter a number: 5
Enter a number: -2
The sum is 8. 




-> In the above program, the user enters a number. 
-> The while loop is used to print the total sum of positive numbers entered by the user.


Notice the use of the continue statement.
if (isNaN(number)) {
 continue;
}

• When the user enters a non-numeric number/string, the continue statement skips the current iteration. 
     Then the control flow of the program goes to the condition of while loop.
• When the user enters a number less than 0, the loop terminates.



-> In the above program, isNaN() is used to check if the value entered by a user is a number or not.




continue with Nested Loop:

-> When continue is used inside of two nested loops, continue skips the current iteration of the inner loop. 

For example,
// nested for loops
// first loop
for (let i = 1; i <= 3; i++) {
 // second loop
 for (let j = 1; j <= 3; j++) {
 if (j == 2) {
 continue;
 }
 console.log(`i = ${i}, j = ${j}`);
 }
}


Output:
i = 1, j = 1
i = 1, j = 3
i = 2, j = 1
i = 2, j = 3
i = 3, j = 1
i = 3, j = 3



-> In the above program, when the continue statement executes, it skips the current iteration in the inner loop and control flow of the program moves to the 
     updateExpression of the inner loop.
-> Hence, the value of j = 2 is never displayed in the output.




JavaScript Labeled continue:

-> When using nested loops, you can skip the current iteration and the control flow of the program can be passed to a label statement's updateExpression.
-> But labeled continue is rarely used in JavaScript because this makes the code harder to read and understand.




JavaScript Switch Statement:

-> The JavaScript switch statement is used in decision making.
-> The switch statement evaluates an expression and executes the corresponding body that matches the expression's result.


The syntax of the switch statement is:
switch(variable/expression) {
 case value1: 
 // body of case 1
 break;
 case value2: 
 // body of case 2
 break;
 case valueN:
 // body of case N
 break;
 default:
 // body of default
}


-> The switch statement evaluates a variable/expression inside parentheses ().
• If the result of the expression is equal to value1, its body is executed.
• If the result of the expression is equal to value2, its body is executed.
• This process goes on. If there is no matching case, the default body executes.




Notes:
• The break statement is optional. If the break statement is encountered, the switch statement ends.
• If the break statement is not used, the cases after the matching case are also executed.
• The default clause is also optional.




Example 1: Simple Program Using switch Statement

// program using switch statement
let a = 2;
switch (a) {
 case 1:
 a = 'one';
 break;
 case 2:
 a = 'two';
 break;
 default:
 a = 'not found';
 break;
}
console.log(`The value is ${a}`);


Output:
The value is two.




In the above program, an expression a = 2 is evaluated with a switch statement.
• The expression's result is evaluated with case 1 which results in false.
• Then the switch statement goes to the second case. Here, the expression's result matches with case 2. So The value is two is displayed.
• The break statement terminates the block and control flow of the program jumps to outside of the switch block.




Example 2: Type Checking in switch Statement

// program using switch statement
let a = 1;
switch (a) {
 case "1":
 a = 1;
 break;
 case 1:
 a = 'one';
 break;
 case 2:
 a = 'two';
 break;
 default:
 a = 'not found';
 break;
}
console.log(`The value is ${a}`);

Output:
The value is one.




-> In the above program, an expression a = 1 is evaluated with a switch statement.

• In JavaScript, the switch statement checks the value strictly. So the expression's result does not match with case "1".
• Then the switch statement goes to the second case. Here, the expressions's result matches with case 1. So The value is one is displayed.
• The break statement terminates the block and control flow of the program jumps to outside of the switch block.


Notes: 
-> In JavaScript, the switch statement checks the cases strictly (should be of the same data type) with the expression's result. 

Notice in the above example, 1 does not match with "1".




Let's write a program to make a simple calculator with the switch statement.

Example 3: Simple Calculator

// program for a simple calculator
let result;

// take the operator input
const operator = prompt('Enter operator ( either +, -, * or / ): ');

// take the operand input
const number1 = parseFloat(prompt('Enter first number: '));
const number2 = parseFloat(prompt('Enter second number: '));
switch(operator) {
 
 case '+':
 result = number1 + number2;
 console.log(`${number1} + ${number2} = ${result}`);
 break;
 
 case '-':
 result = number1 - number2;
 console.log(`${number1} - ${number2} = ${result}`);
 break;
 
 case '*':
 result = number1 * number2;
 console.log(`${number1} * ${number2} = ${result}`);
 break;
 
 case '/':
 result = number1 / number2;
 console.log(`${number1} / ${number2} = ${result}`);
 break;
 
 default:
 console.log('Invalid operator');
 break;
}

Output:
Enter operator: +
Enter first number: 4
Enter second number: 5
4 + 5 = 9

-> In above program, the user is asked to enter either +, -, * or /, and two operands. 
-> Then, the switch statement executes cases based on the user input.




JavaScript switch With Multiple Case:

-> In a JavaScript switch statement, cases can be grouped to share the same code.


Example 4: switch With Multiple Case
// multiple case switch program
let fruit = 'apple';
switch(fruit) {
 case 'apple':
 case 'mango':
 case 'pineapple':
 console.log(`${fruit} is a fruit.`);
 break;
 default:
 console.log(`${fruit} is not a fruit.`);
 break;
}

Output:
apple is a fruit.


-> In the above program, multiple cases are grouped. All the grouped cases share the same code.
-> If the value of the fruit variable had value mango or pineapple, the output would have been the same.




JavaScript Function and Function Expressions:

JavaScript Function

-> A function is a block of code that performs a specific task.
-> Suppose you need to create a program to create a circle and color it. 


You can create two functions to solve this problem:
• a function to draw the circle
• a function to color the circle

-> Dividing a complex problem into smaller chunks makes your program easy to understand and reusable.
-> JavaScript also has a huge number of inbuilt functions. 
-> For example, Math.sqrt() is a function to calculate the square root of a number.




Declaring a Function:

The syntax to declare a function is:
function nameOfFunction () {
 // function body 
}

• A function is declared using the function keyword.
• The basic rules of naming a function are similar to naming a variable. 
     It is better to write a descriptive name for your function. 
     For example, if a function is used to add two numbers, you could name the function add or addNumbers.
• The body of function is written within {}.


For example,
// declaring a function named greet()
function greet() {
 console.log("Hello there");
}




Calling a Function:

-> In the above program, we have declared a function named greet(). 
-> To use that function, we need to call it.

Here's how you can call the above greet() function.
// function call
greet();




Example 1: Display a Text

// program to print a text
// declaring a function
function greet() {
 console.log("Hello there!");
}
// calling the function
greet();

Output:
Hello there!




Function Parameters:

-> A function can also be declared with parameters. 
-> A parameter is a value that is passed when declaring a function.


Example 2: Function with Parameters

// program to print the text
// declaring a function
function greet(name) {
 console.log("Hello " + name + ":)");
}

// variable name can be different
let name = prompt("Enter a name: ");

// calling function
greet(name);

Output:
Enter a name: Simon
Hello Simon :)



-> In the above program, the greet function is declared with a name parameter. 
-> The user is prompted to enter a name. 
-> Then when the function is called, an argument is passed into the function.


Notes: 
-> When a value is passed when declaring a function, it is called parameter. 
-> And when the function is called, the value passed is called argument.




Example 3: Add Two Numbers
// program to add two numbers using a function
// declaring a function
function add(a, b) {
 console.log(a + b);
}
// calling functions
add(3,4);
add(2,9);

Output:
7
11




-> In the above program, the add function is used to find the sum of two numbers.
• The function is declared with two parameters a and b.
• The function is called using its name and passing two arguments 3 and 4 in one and 2 and 9 in another.


-> Notice that you can call a function as many times as you want. 
-> You can write one function and then call it multiple times with different arguments.




Function Return:

-> The return statement can be used to return the value to a function call.
-> The return statement denotes that the function has ended. Any code after return is not executed.
-> If nothing is returned, the function returns an undefined value.




Example 4: Sum of Two Numbers

// program to add two numbers
// declaring a function
function add(a, b) {
 return a + b;
}

// take input from the user
let number1 = parseFloat(prompt("Enter first number: "));
let number2 = parseFloat(prompt("Enter second number: "));

// calling function
let result = add(number1,number2);

// display the result
console.log("The sum is " + result);


Output:
Enter first number: 3.4
Enter second number: 4
The sum is 7.4




-> In the above program, the sum of the numbers is returned by the function using the return statement. 
-> And that value is stored in the result variable.


Benefits of Using a Function
• Function makes the code reusable. You can declare it once and use it multiple times.
• Function makes the program easier as each small task is divided into a function.
• Function increases readability.



Function Expressions:

-> In Javascript, functions can also be defined as expressions. 

For example,
// program to find the square of a number
// function is declared inside the variable
let x = function (num) { return num * num };
console.log(x(4));

// can be used as variable value for other variables
let y = x(3);
console.log(y);


Output:
16
9




-> In the above program, variable x is used to store the function. 
-> Here the function is treated as an expression. 
-> And the function is called using the variable name.
-> The function above is called an anonymous function.


Note: In ES2015, JavaScript expressions are written as arrow functions.




JavaScript Variable Scope:

-> Scope refers to the availability of variables and functions in certain parts of the code.


In JavaScript, a variable has two types of scope:
1. Global Scope
2. Local Scope


Global Scope:
-> A variable declared at the top of a program or outside of a function is considered a global scope variable.


Let's see an example of a global scope variable.
// program to print a text 
let a = "hello";
function greet () {
 console.log(a);
}
greet(); // hello

-> In the above program, variable a is declared at the top of a program and is a global variable. 
-> It means the variable a can be used anywhere in the program.



-> The value of a global variable can be changed inside a function. 

For example,
// program to show the change in global variable
let a = "hello";
function greet() {
 a = 3;
}
// before the function call
console.log(a);

//after the function call
greet();
console.log(a); // 3



-> In the above program, variable a is a global variable. 
-> The value of a is hello. 

-> Then the variable a is accessed inside a function and the value changes to 3.
-> Hence, the value of a changes after changing it inside the function.


Notes: 
-> It is a good practice to avoid using global variables because the value of a global variable can change in different areas in the program. 
-> It can introduce unknown results in the program.

-> In JavaScript, a variable can also be used without declaring it. 
-> If a variable is used without declaring it, that variable automatically becomes a global variable.


For example,
function greet() {
 a = "hello"
}
greet();
console.log(a); // hello

-> In the above program, variable a is a global variable.
-> If the variable was declared using let a = "hello", the program would throw an error.

Notes: 
-> In JavaScript, there is "strict mode"; in which a variable cannot be used without declaring it.




Local Scope:

-> A variable can also have a local scope, i.e it can only be accessed within a function.


Example 1: Local Scope Variable
// program showing local scope of a variable
let a = "hello";
function greet() {
 let b = "World"
 console.log(a + b);
}
greet();
console.log(a + b); // error

Output:
helloWorld
Uncaught ReferenceError: b is not defined




-> In the above program, variable a is a global variable and variable b is a local variable. 
-> The variable b can be accessed only inside the function greet. 
-> Hence, when we try to access variable b outside of the function, an error occurs.





let is Block Scoped:

-> The let keyword is block-scoped (variable can be accessed only in the immediate block).


Example 2: block-scoped Variable
// program showing block-scoped concept
// global variable
let a = 'Hello';
function greet() {
 // local variable
 let b = 'World';
 console.log(a + ' ' + b);
 if (b == 'World') {
 // block-scoped variable
 let c = 'hello';
 console.log(a + ' ' + b + ' ' + c);
 }
 // variable x cannot be accessed here
 console.log(a + ' ' + b + ' ' + c);
}
greet();


Output:
Hello World
Hello World hello

Uncaught ReferenceError: x is not defined


-> In the above program, variable
• a is a global variable. It can be accessed anywhere in the program.
• b is a local variable. It can be accessed only inside the function greet.
• c is a block-scoped variable. It can be accessed only inside the if statement block.


-> Hence, in the above program, the first two console.log() work without any issue.
-> However, we are trying to access the block-scoped variable c outside of the block in the third console.log(). 
-> This will throw an error.


Notes: 
-> In JavaScript, var is function scoped and let is block-scoped. 
-> If you try to use 
     var c = 'hello'; 
-> inside the if statement in the above program, the whole program works, as c is treated as a local variable.




JavaScript Hoisting:

-> Hoisting in JavaScript is a behavior in which a function or a variable can be used before declaration. 


For example,
// using test before declaring
console.log(test); // undefined
var test;

-> The above program works and the output will be undefined. 
-> The above program behaves as
// using test before declaring
var test;
console.log(test); // undefined


-> Since the variable test is only declared and has no value, undefined value is assigned to it.

Notes: 
-> In hoisting, though it seems that the declaration has moved up in the program, the actual thing that happens is that the function and variable declarations 
       are added to memory during the compile phase.




Variable Hoisting:

-> In terms of variables and constants, keyword var is hoisted and let and const does not allow hoisting.


For example,
// program to display value
a = 5;
console.log(a);
var a; // 5

-> In the above example, variable a is used before declaring it. 
-> And the program works and displays the output 5. 


The program behaves as:
// program to display value
var a;
a = 5;
console.log(a); // 5


-> However in JavaScript, initializations are not hoisted. 

For example,
// program to display value
console.log(a);
var a = 5;

Output:
undefined


-> The above program behaves as:
var a;
console.log(a);
a = 5;




-> Only the declaration is moved to the memory in the compile phase. 
-> Hence, the value of variable a is undefined because a is printed without initializing it.

-> Also, when the variable is used inside the function, the variable is hoisted only to the top of the function. 

For example,
// program to display value
var a = 4;
function greet() {
 b = 'hello';
 console.log(b); // hello
 var b;
}
greet(); // hello
console.log(b);


Output:
hello
Uncaught ReferenceError: b is not defined



-> In the above example, variable b is hoisted to the top of the function greet and becomes a local variable. 
-> Hence b is only accessible inside the function. b does not become a global variable.



-> If a variable is used with the let keyword, that variable is not hoisted. 

For example,
// program to display value
a = 5;
console.log(a);
let a; // error

Output:
Uncaught ReferenceError: Cannot access 'a' before initialization

-> While using let, the variable must be declared first.




Function Hoisting:
-> A function can be called before declaring it. 

For example,
// program to print the text
greet();
function greet() {
 console.log('Hi, there.');
}

Output:
Hi, there




-> In the above program, the function greet is called before declaring it and the program shows the output. 
-> This is due to hoisting.


-> However, when a function is used as an expression, an error occurs because only declarations are hoisted. 

For example;
// program to print the text
greet();
let greet = function() {
 console.log('Hi, there.');
}

Output:
Uncaught ReferenceError: greet is not defined




-> If var was used in the above program, the error would be:
Uncaught TypeError: greet is not a function

Notes: 
-> Generally, hoisting is not performed in other programming languages like Python, C, C++, Java.
-> Hoisting can cause undesirable outcomes in your program. 
-> And it is best to declare variables and functions first before using them and avoid hoisting.
-> In the case of variables, it is better to use let than var.




JavaScript Recursion:

-> Recursion is a process of calling itself. 
-> A function that calls itself is called a recursive function.

The syntax for recursive function is:
function recurse() {
 // function code
 recurse();
 // function code
}
recurse();


-> Here, the recurse() function is a recursive function. 
-> It is calling itself inside the function.




-> A recursive function must have a condition to stop calling itself. 
-> Otherwise, the function is called indefinitely.


-> Once the condition is met, the function stops calling itself. 
-> This is called a base condition.

-> To prevent infinite recursion, you can use if...else statement (or similar approach) where one branch makes the recursive call, and the other doesn't.




-> So, it generally looks like this.
function recurse() {
 if(condition) {
 recurse();
 }
 else {
 // stop calling recurse()
 }
}
recurse();

-> A simple example of a recursive function would be to count down the value to 1.




Example 1: Print Numbers
// program to count down numbers to 1
function countDown(number) {
 
 // display the number
 console.log(number);
 
 // decrease the number value
 const newNumber = number - 1;
 
 // base case
 if (newNumber > 0) {
 countDown(newNumber);
 }
}
countDown(4);

Output:
4
3
2
1





-> In the above program, the user passes a number as an argument when calling a function.

-> In each iteration, the number value is decreased by 1 and function countDown() is called until the number is positive. 
-> Here, newNumber > 0 is the base condition.

This recursive call can be explained in the following steps:
countDown(4) prints 4 and calls countDown(3)
countDown(3) prints 3 and calls countDown(2)
countDown(2) prints 2 and calls countDown(1)
countDown(1) prints 1 and calls countDown(0)

-> When the number reaches 0, the base condition is met, and the function is not called anymore.




Example 2: Find Factorial
// program to find the factorial of a number
function factorial(x) {
 // if number is 0
 if (x === 0) {
 return 1;
 }
 // if number is positive
 else {
 return x * factorial(x - 1);
 }
}
const num = 3;
// calling factorial() if num is non-negative
if (num > 0) {
 let result = factorial(num);
 console.log(`The factorial of ${num} is ${result}`);
}

Output:
The factorial of 3 is 6




-> When you call function factorial() with a positive integer, it will recursively call itself by decreasing the number.
-> This process continues until the number becomes 1. Then when the number reaches 0, 1 is returned.




-> This recursive call can be explained in the following steps:
factorial(3) returns 3 * factorial(2)
factorial(2) returns 3 * 2 * factorial(1)
factorial(1) returns 3 * 2 * 1 * factorial(0)
factorial(0) returns 3 * 2 * 1 * 1




JavaScript Objects:

-> JavaScript object is a non-primitive data-type that allows you to store multiple collections of data.


Notes: 
-> If you are familiar with other programming languages, JavaScript objects are a bit different. 
-> You do not need to create classes in order to create objects.


Here is an example of a JavaScript object.
// object
const student = {
 firstName: 'ram',
 class: 10
};

-> Here, student is an object that stores values such as strings and numbers.




JavaScript Object Declaration:

The syntax to declare an object is:
const object_name = {
 key1: value1,
 key2: value2
}

Here, an object object_name is defined. Each member of an object is a key: valuepair separated by commas and enclosed in curly braces {}.

For example,
// object creation
const person = { 
 name: 'John',
 age: 20
};
console.log(typeof person); // object


-> You can also define an object in a single line.

const person = { name: 'John', age: 20 };

-> In the above example, name and age are keys, and John and 20 are values respectively.
-> There are other ways to declare an object in JavaScript.




JavaScript Object Properties:

-> In JavaScript, "key: value" pairs are called properties. 

For example,
let person = { 
 name: 'John',
 age: 20
};

-> Here, name: 'John' and age: 20 are properties.




Accessing Object Properties:

You can access the value of a property by using its key.

1. Using dot Notation

Here's the syntax of the dot notation.
objectName.key
For example,
const person = { 
 name: 'John', 
 age: 20, 
};

// accessing property
console.log(person.name); // John




2. Using bracket Notation

Here is the syntax of the bracket notation.
objectName["propertyName"]
For example,
const person = { 
 name: 'John', 
 age: 20, 
};

// accessing property
console.log(person["name"]); // John





JavaScript Nested Objects:

-> An object can also contain another object. 

For example,
// nested object
const student = { 
 name: 'John', 
 age: 20,
 marks: {
 science: 70,
 math: 75
 }
}

// accessing property of student object
console.log(student.marks); // {science: 70, math: 75}

// accessing property of marks object
console.log(student.marks.science); // 70

-> In the above example, an object student contains an object value in the marks property.




JavaScript Object Methods:

-> In JavaScript, an object can also contain a function. 

For example,
const person = {
 name: 'Sam',
 age: 30,
 // using function as a value
 greet: function() { console.log('hello') }
}
person.greet(); // hello


-> Here, a function is used as a value for the greet key. 
-> That's why we need to use person.greet() instead of person.greet to call the function inside the object.

-> A JavaScript method is a property containing a function declaration.




JavaScript Methods and this Keyword:

-> In JavaScript, objects can also contain functions. For example,

// object containing method
const person = {
 name: 'John',
 greet: function() { console.log('hello'); }
};

-> In the above example, a person object has two keys (name and greet), which have a string value and a function value, respectively.
-> Hence basically, the JavaScript method is an object property that has a function value.




Accessing Object Methods:

->  You can access an object method using a dot notation. The syntax is:
objectName.methodKey()

-> You can access property by calling an objectName and a key. 
-> You can access a method by calling an objectName and a key for that method along with (). 



For example,
// accessing method and property
const person = {
 name: 'John',
 greet: function() { console.log('hello'); }
};

// accessing property
person.name; // John

// accessing method
person.greet(); // hello


-> Here, the greet method is accessed as person.greet() instead of person.greet.
-> If you try to access the method with only person.greet, it will give you a function definition.
person.greet; // ƒ () { console.log('hello'); }




JavaScript Built-In Methods:

-> In JavaScript, there are many built-in methods. 

For example,
let number = '23.32';
let result = parseInt(number);
console.log(result); // 23

-> Here, the parseInt() method of Number object is used to convert numeric string value to an integer value.




Adding a Method to a JavaScript Object:

-> You can also add a method in an object. 

For example,
// creating an object
let student = { };

// adding a property
student.name = 'John';

// adding a method
student.greet = function() {
 console.log('hello');
}

// accessing a method
student.greet(); // hello



-> In the above example, an empty student object is created. 
-> Then, the name property is added. 
-> Similarly, the greet method is also added. 
-> In this way, you can add a method as well as property to an object.




JavaScript this Keyword:

-> To access a property of an object from within a method of the same object, you need to use the this keyword. 

Let's consider an example.
const person = {
 name: 'John',
 age: 30,
 // accessing name property by using this.name
 greet: function() { console.log('The name is' + ' ' + this.name); 
}
};
person.greet();

Output:
The name is John


-> In the above example, a person object is created. 
-> It contains properties (name and age) and a method greet.


-> In the method greet, while accessing a property of an object, this keyword is used.

-> In order to access the properties of an object, this keyword is used following by .and key.


Notes: 
-> In JavaScript, this keyword when used with the object's method refers to the object. this is bound to an object.

-> However, the function inside of an object can access it's variable in a similar way as a normal function would. 

For example,
const person = {
 name: 'John',
 age: 30,
 greet: function() {
 let surname = 'Doe';
 console.log('The name is' + ' ' + this.name + ' ' + surname); 
}
};
person.greet();


Output:
The name is John Doe




JavaScript Constructor Function:

-> In JavaScript, a constructor function is used to create objects. For example,
// constructor function
function Person () {
 this.name = 'John',
 this.age = 23
}

// create an object
const person = new Person();


-> In the above example, function Person() is an object constructor function.
-> To create an object from a constructor function, we use the new keyword.


Notes: 
-> It is considered a good practice to capitalize the first letter of your constructor function.




Create Multiple Objects with Constructor Function:

-> In JavaScript, you can create multiple objects from a constructor function. 

For example,
// constructor function
function Person () {
 this.name = 'John',
 this.age = 23,
 this.greet = function () {
 console.log('hello');
 }
}
// create objects
const person1 = new Person();
const person2 = new Person();
// access properties
console.log(person1.name); // John
console.log(person2.name); // John

-> In the above program, two objects are created using the same constructor function




JavaScript this Keyword:

-> In JavaScript, when this keyword is used in a constructor function, this refers to the object when the object is created. 

For example,
// constructor function
function Person () {
 this.name = 'John',
}
// create object
const person1 = new Person();
// access properties
console.log(person1.name); // John

-> Hence, when an object accesses the properties, it can directly access the property as person1.name.




JavaScript Constructor Function Parameters:

-> You can also create a constructor function with parameters. 

For example,
// constructor function
function Person (person_name, person_age, person_gender) {
 // assigning parameter values to the calling object
 this.name = person_name,
 this.age = person_age,
 this.gender = person_gender,
 this.greet = function () {
 return ('Hi' + ' ' + this.name);
 }
}

// creating objects
const person1 = new Person('John', 23, 'male');
const person2 = new Person('Sam', 25, 'female');

// accessing properties
console.log(person1.name); // "John"
console.log(person2.name); // "Sam"



-> In the above example, we have passed arguments to the constructor function during the creation of the object.
const person1 = new Person('John', 23, 'male');
const person2 = new Person('Sam', 25, 'male');


-> This allows each object to have different properties. 

As shown above,
console.log(person1.name); gives John
console.log(person2.name); gives Sam




Create Objects: Constructor Function Vs Object Literal:


• Object Literal is generally used to create a single object. 

The constructor function is useful if you want to create multiple objects. 

For example,
// using object literal
let person = {
 name: 'Sam'
}
// using constructor function
function Person () {
 this.name = 'Sam'
}
let person1 = new Person();
let person2 = new Person();





• Each object created from the constructor function is unique. 
    You can have the same properties as the constructor function or add a new property to one particular object. 
    
    
For example,
// using constructor function
function Person () {
 this.name = 'Sam'
}
let person1 = new Person();
let person2 = new Person();
// adding new property to person1
person1.age = 20;


Notes:
-> Now this age property is unique to person1 object and is not available to person2 object.


-> However, if an object is created with an object literal, and if a variable is defined with that object value, 
      any changes in variable value will change the original object. 
      
      
For example,
// using object lateral
let person = {
 name: 'Sam'
}
console.log(person.name); // Sam
let student = person;

// changes the property of an object
student.name = 'John';

// changes the origins object property
console.log(person.name); // John


-> When an object is created with an object literal, any object variable derived from that object will act as a clone of the original object.
-> Hence, any change you make in one object will also reflect in the other object.




Adding Properties And Methods in an Object:

-> You can add properties or methods in an object like this:

// constructor function
function Person () {
 this.name = 'John',
 this.age = 23
}

// creating objects
let person1 = new Person();
let person2 = new Person();

// adding property to person1 object
person1.gender = 'male';

// adding method to person1 object
person1.greet = function () {
 console.log('hello');
}
person1.greet(); // hello

// Error code
// person2 doesn't have greet() method
person2.greet();


Output:
hello
Uncaught TypeError: person2.greet is not a function




-> In the above example, a new property gender and a new method greet() is added to the person1 object.
-> However, this new property and method is only added to person1. 
-> You cannot access gender or greet() from person2. 

-> Hence the program gives error when we try to access person2.greet();




JavaScript Object Prototype:

-> You can also add properties and methods to a constructor function using a prototype. 

For example,
// constructor function
function Person () {
 this.name = 'John',
 this.age = 23
}

// creating objects
let person1 = new Person();
let person2 = new Person();

// adding new property to constructor function
Person.prototype.gender = 'Male';
console.log(person1.gender); // Male
console.log(person2.gender); // Male




JavaScript Built-in Constructors:

-> JavaScript also has built-in constructors. 

Some of them are:
let a = new Object(); // A new Object object
let b = new String(); // A new String object
let c = new Number(); // A new Number object
let d = new Boolean(); // A new Boolean object


-> In JavaScript, strings can be created as objects by:
const name = new String ('John');
console.log(name); // "John"


-> In JavaScript, numbers can be created as objects by:
const number = new Number (57);
console.log(number); // 57


-> In JavaScript, booleans can be created as objects by:
const count = new Boolean(true);
console.log(count); // true




Note: It is recommended to use primitive data types and create them in a normal way, such as

const name = 'John';, const number = 57; and const count = true;

You should not declare strings, numbers, and boolean values as objects because they slow down the program.

Note: In JavaScript, the keyword class was introduced in ES6 (ES2015) that also allows us to create objects. 
-> Classes are similar to constructor functions in JavaScript.




JavaScript Getter and Setter:

-> In JavaScript, there are two kinds of object properties:
• Data properties
• Accessor properties



Data Property:

Example:
const student = {
 // data property
 firstName: 'Monica';
};




Accessor Property:

-> In JavaScript, accessor properties are methods that get or set the value of an object. 

For that, we use these two keywords:
• get - to define a getter method to get the property value
• set - to define a setter method to set the property value




JavaScript Getter:

-> In JavaScript, getter methods are used to access the properties of an object. 


For example,
const student = {
 
 // data property
 firstName: 'Monica',
 
 // accessor property(getter)
 get getName() {
 return this.firstName;
 }
};

// accessing data property
console.log(student.firstName); // Monica

// accessing getter methods
console.log(student.getName); // Monica

// trying to access as a method
console.log(student.getName()); // error


-> In the above program, a getter method getName() is created to access the property of an object.
get getName() {
 return this.firstName;
}

Notes: 
-> To create a getter method, the get keyword is used.




-> And also when accessing the value, we access the value as a property.
student.getName;

-> When you try to access the value as a method, an error occurs.
console.log(student.getName()); // error




JavaScript Setter:

-> In JavaScript, setter methods are used to change the values of an object. 

For example,
const student = {
 firstName: 'Monica',
 
 //accessor property(setter)
 set changeName(newName) {
 this.firstName = newName;
 }
};
console.log(student.firstName); // Monica

// change(set) object property using a setter
student.changeName = 'Sarah';
console.log(student.firstName); // Sarah


-> In the above example, the setter method is used to change the value of an object.
set changeName(newName) {
 this.firstName = newName;
}


Notes: 
-> To create a setter method, the set keyword is used.

-> As shown in the above program, the value of firstName is Monica.
-> Then the value is changed to Sarah.

student.chageName = 'Sarah';

-> Setter must have exactly one formal parameter.




JavaScript Object.defineProperty():

-> In JavaScript, you can also use Object.defineProperty() method to add getters and setters. 

For example,
const student = {
 firstName: 'Monica'
}

// getting property
Object.defineProperty(student, "getName", {
 get : function () {
 return this.firstName;
 }
});

// setting property
Object.defineProperty(student, "changeName", {
 set : function (value) {
 this.firstName = value;
 }
});
console.log(student.firstName); // Monica

// changing the property value
student.changeName = 'Sarah';
console.log(student.firstName); // Sarah



-> In the above example, Object.defineProperty() is used to access and change the property of an object.


The syntax for using Object.defineProperty() is:
Object.defineProperty(obj, prop, descriptor)


The Object.defineProperty() method takes three arguments.
• The first argument is the objectName.
• The second argument is the name of the property.
• The third argument is an object that describes the property.




JavaScript Prototype:

• JavaScript Objects
• JavaScript Constructor Function


-> As you know, you can create an object in JavaScript using an object constructor function. 

For example,
// constructor function
function Person () {
 this.name = 'John',
 this.age = 23
}

// creating objects
const person1 = new Person();
const person2 = new Person();


-> In the above example, function Person() is an object constructor function. 
-> We have created two objects person1 and person2 from it.




JavaScript Prototype:

-> In JavaScript, every function and object has a property named prototype by default. 


For example,
function Person () {
 this.name = 'John',
 this.age = 23
}
const person = new Person();

// checking the prototype value
console.log(Person.prototype); // { ... }


-> In the above example, we are trying to access the prototype property of a Person constructor function.
-> Since the prototype property has no value at the moment, it shows an empty object { ... }.





Prototype Inheritance:

-> In JavaScript, a prototype can be used to add properties and methods to a constructor function. 
-> And objects inherit properties and methods from a prototype. 


For example,
// constructor function
function Person () {
 this.name = 'John',
 this.age = 23
}

// creating objects
const person1 = new Person();
const person2 = new Person();

// adding property to constructor function
Person.prototype.gender = 'male';

// prototype value of Person
console.log(Person.prototype);

// inheriting the property from prototype
console.log(person1.gender);
console.log(person2.gender);


Output:
{ gender: "male" }
male
male




-> In the above program, we have added a new property gender to the Person constructor function using:
Person.prototype.gender = 'male';

-> Then object person1 and person2 inherits the property gender from the prototype property of Person constructor function.

-> Hence, both objects person1 and person2 can access the gender property.

Notes:
-> The syntax to add the property to an object constructor function is:
objectConstructorName.prototype.key = 'value';

-> Prototype is used to provide additional property to all the objects created from a constructor function.




Add Methods to a Constructor Function Using Prototype:

-> You can also add new methods to a constructor function using prototype. 

For example,
// constructor function
function Person () {
 this.name = 'John',
 this.age = 23
}

// creating objects
const person1 = new Person();
const person2 = new Person();

// adding a method to the constructor function
Person.prototype.greet = function() {
 console.log('hello' + ' ' + this.name);
}
person1.greet(); // hello John
person2.greet(); // hello John


-> In the above program, a new method greet is added to the Person constructor function using a prototype.




Changing Prototype:

-> If a prototype value is changed, then all the new objects will have the changed property value. 

-> All the previously created objects will have the previous value. 

For example,
// constructor function
function Person() {
 this.name = 'John'
}

// add a property
Person.prototype.age = 20;

// creating an object
const person1 = new Person();
console.log(person1.age); // 20

// changing the property value of prototype
Person.prototype = { age: 50 }

// creating new object
const person3 = new Person();
console.log(person3.age); // 50
console.log(person1.age); // 20


Notes: 
-> You should not modify the prototypes of standard JavaScript built-in objects like strings, arrays, etc. It is considered a bad practice.




JavaScript Prototype Chaining:

-> If an object tries to access the same property that is in the constructor function and the prototype object, 
      the object takes the property from the constructor function. 


For example,
function Person() {
 this.name = 'John'
}
// adding property 
Person.prototype.name = 'Peter';
Person.prototype.age = 23
const person1 = new Person();
console.log(person1.name); // John
console.log(person1.age); // 23



-> In the above program, a property name is declared in the constructor function and also in the prototype property of the constructor function.

-> When the program executes, person1.name looks in the constructor function to see if there is a property named name. 
-> Since the constructor function has the name
       property with value 'John', the object takes value from that property.

-> When the program executes, person1.age looks in the constructor function to see if there is a property named age. 
-> Since the constructor function doesn't have age property, the program looks into the prototype object of the constructor function 
       and the object inherits property from the prototype object (if available).




Note: You can also access the prototype property of a constructor function from an object.

function Person () {
 this.name = 'John'
}
// adding a prototype
Person.prototype.age = 24;

// creating object
const person = new Person();

// accessing prototype property
console.log(person.__proto__); // { age: 24 }


-> In the above example, a person object is used to access the prototype property using __proto__. However, __proto__ has been deprecated 
      and you should avoid using it.
      
      
      
      





















































































































